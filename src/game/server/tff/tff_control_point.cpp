// Purpose: Body for tff_control_point
// Boilerplate generated by ModMaker on 23/05/2018 07:44:09
/* */

#include "cbase.h"
#include "tff_control_point.h"
#include "tff_team_entity.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

LINK_ENTITY_TO_CLASS( tff_control_point, CTffControlPoint );

BEGIN_DATADESC( CTffControlPoint )
    DEFINE_KEYFIELD( m_iSequence, FIELD_INTEGER, "sequence" ),
    DEFINE_KEYFIELD( m_iRadius, FIELD_INTEGER, "radius" ),
    DEFINE_KEYFIELD( m_flCaptureTime, FIELD_FLOAT, "capture_time" ),
    DEFINE_KEYFIELD( m_vecCameraOffset, FIELD_VECTOR, "camera_offset" ),
    DEFINE_KEYFIELD( m_iStartCaptureSound, FIELD_SOUNDNAME, "start_capture_sound" ),
    DEFINE_KEYFIELD( m_iContestedCaptureSound, FIELD_SOUNDNAME, "contested_capture_sound" ),
    DEFINE_KEYFIELD( m_iLoopCaptureSound, FIELD_SOUNDNAME, "loop_capture_sound" ),
    DEFINE_KEYFIELD( m_iFinishCaptureSound, FIELD_SOUNDNAME, "finish_capture_sound" ),
    DEFINE_KEYFIELD( m_iLockedSound, FIELD_SOUNDNAME, "locked_sound" ),
    DEFINE_OUTPUT( m_OnCaptureStart, "OnCaptureStart" ),
    DEFINE_OUTPUT( m_OnContested, "OnContested" ),
    DEFINE_OUTPUT( m_OnCaptured, "OnCaptured" ),
END_DATADESC()

void CTffControlPoint ::Precache()
{
    PrecacheScriptSound( STRING(m_iStartCaptureSound) );
    PrecacheScriptSound( STRING(m_iContestedCaptureSound) );
    PrecacheScriptSound( STRING(m_iLoopCaptureSound) );
    PrecacheScriptSound( STRING(m_iFinishCaptureSound) );
    PrecacheScriptSound( STRING(m_iLockedSound) );
}
void CTffControlPoint ::Spawn()
{
    BaseClass::Spawn();

    Precache();

	m_eState = IDLE;
	InitNextAndPrevious();

	SetContextThink(&CTffControlPoint::CP_Think, gpGlobals->curtime + 0.5f, "control");
}

void CTffControlPoint::CP_Think()
{
	CPCheckPlayers();

	CP_State currentState    = m_eState;
	CBaseEntity * pActivator = NULL;

	if (m_iEnemies == 0)
	{
		currentState = IDLE;
		pActivator = this;

		
		if (m_fCaptureFinishTIme < m_flCaptureTime)
		{
			if (m_iAllies > 0)
			{
				//allies securing the points
				m_fCaptureFinishTIme = m_fCaptureFinishTIme + 0.5f;
			} else {
				//capture progress decays when no players are presnet
				m_fCaptureFinishTIme = m_fCaptureFinishTIme + 0.25f;
			}			
		}
	} //end no emeies
	else if (m_iEnemies > 0)
	{
		//we have enemies in proximity, but have they captured the previous points in the chain?
		bool CanComprimise = false;

		if (GetTeamNumber() == TEAM_BLUE || GetTeamNumber() == TEAM_UNASSIGNED )
		{
			if (m_hPrevCP.IsValid())
			{
				CanComprimise = (m_hPrevCP.Get()->GetTeamNumber() == TEAM_RED);
			}
		}

		if (GetTeamNumber() == TEAM_RED || GetTeamNumber() == TEAM_UNASSIGNED)
		{
			if (m_hNextCP.IsValid())
			{
				CanComprimise = (m_hPrevCP.Get()->GetTeamNumber() == TEAM_BLUE);
			}
		}

		if (CanComprimise)
		{
			if (m_iAllies > 0)
			{
				currentState = CONTESTED;
				pActivator = m_pEnemy;
			}

			//No allies, we are capturable
			if (m_iAllies == 0)
			{
				if (m_eState == CAPTURING)
				{
					int MaxEnemies = min(3, m_iEnemies);

					m_fCaptureFinishTIme = m_fCaptureFinishTIme - (0.5f * MaxEnemies);

					//No capture time remaining
					if (m_fCaptureFinishTIme < 0.0f)
					{
						//Fully captured!
						ChangeTeam(m_pEnemy->GetTeamNumber());
						m_OnCaptured.FireOutput(m_pEnemy, this);
						EmitSound(STRING(m_iFinishCaptureSound));
						currentState = IDLE;
						pActivator = m_pEnemy;
					}
					else {
						EmitSound(STRING(m_iLoopCaptureSound));
					}
				} else {
					//starting to capture
					m_fCaptureFinishTIme = m_flCaptureTime;
					currentState = CAPTURING;
					pActivator = m_pEnemy;
				}
			}//end No allies, we are capturable
		}//end compromisable
	}//end we has 

	SetState(currentState, pActivator);
	//think again soon
	SetContextThink(&CTffControlPoint::CP_Think, gpGlobals->curtime + 0.5f, "control");
};

void CTffControlPoint::InitNextAndPrevious()
{
	CBaseEntity * pEnt = gEntList.FindEntityByClassname(NULL, "tff_control_point");
	while (pEnt)
	{
		if (pEnt != this)
		{
			CTffControlPoint * pOther = dynamic_cast<CTffControlPoint *>(pEnt);
			if (pOther)
			{
				if (pOther->m_iSequence == m_iSequence - 1)
				{
					m_hPrevCP = pEnt->GetRefEHandle();
				}
				if (pOther->m_iSequence == m_iSequence + 1)
				{
					m_hNextCP = pEnt->GetRefEHandle();
				}
			}
		}

		pEnt = gEntList.FindEntityByClassname(pEnt, "tff_control_point");
	}
};

//Let's see how many allies and enemies are nearby (split out from think for readability)
void CTffControlPoint::CPCheckPlayers()
{
	//reset our counters
	m_iAllies = 0;
	m_iEnemies = 0;
	m_pEnemy = NULL;

	//foreach player within our effective radius
	CBaseEntity * pPlayer = gEntList.FindEntityInSphere(NULL, GetAbsOrigin(), m_iRadius);
	while (pPlayer)
	{
		if (!pPlayer->IsPlayer() || !pPlayer->IsAlive())
		{
			pPlayer = gEntList.FindEntityInSphere(pPlayer, GetAbsOrigin(), m_iRadius);
			continue;
		}

		if (IsAlly(pPlayer))
		{
			m_iAllies++;
		}
		if (IsEnemy(pPlayer))
		{
			if (m_iEnemies == 0) m_pEnemy = pPlayer;

			m_iEnemies++;
		}

		pPlayer = gEntList.FindEntityInSphere(pPlayer, GetAbsOrigin(), m_iRadius);
	}
}

void CTffControlPoint::SetState(CTffControlPoint::CP_State state, CBaseEntity * activator)
{
	if (m_eState == state) return;

	//Stop sounds related to the old state

	if (m_eState == CONTESTED)
	{
		StopSound(STRING(m_iContestedCaptureSound));
	}

	if (m_eState == CAPTURING)
	{
		StopSound(STRING(m_iStartCaptureSound));
		StopSound(STRING(m_iLoopCaptureSound));
	}

	m_eState = state;

	//Start sounds and fire events related to the new state
	if (state == CONTESTED)
	{
		m_OnContested.FireOutput(activator, this);
		EmitSound(STRING(m_iContestedCaptureSound));
	}

	if (state == CAPTURING)
	{
		m_OnCaptureStart.FireOutput(activator, this);
		EmitSound(STRING(m_iStartCaptureSound));
	}
};