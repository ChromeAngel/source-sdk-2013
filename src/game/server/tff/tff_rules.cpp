// Purpose: Body for tff_rules
// Boilerplate generated by ModMaker on 23/05/2018 07:53:00
/* Game Rules and Timer for TFF*/

#include "cbase.h"
#include "tff_rules.h"
#include "teamplay_gamerules.h"

// memdbgon must be the last include file in a .cpp file!!!
#include "tier0/memdbgon.h"

BEGIN_DATADESC( CTffRules )
    DEFINE_KEYFIELD( m_iSetupTime, FIELD_INTEGER, "setup_time" ),
    DEFINE_KEYFIELD( m_iTimeout, FIELD_INTEGER, "timeout" ),
    DEFINE_KEYFIELD( m_iMode, FIELD_INTEGER, "mode" ),
    DEFINE_INPUTFUNC( FIELD_INPUT, "SetTimeout", SetTimeout ),
    DEFINE_INPUTFUNC( FIELD_INPUT, "AddTime", AddTime ),
    DEFINE_INPUTFUNC( FIELD_INPUT, "RemoveTime", RemoveTime ),
    DEFINE_INPUTFUNC( FIELD_INPUT, "ForceTimeout", ForceTimeout ),
    DEFINE_OUTPUT( m_OnSetupEnded, "OnSetupEnded" ),
    DEFINE_OUTPUT( m_OnTimeout, "OnTimeout" ),
END_DATADESC()

LINK_ENTITY_TO_CLASS(tff_rules, CTffRules);

/* Sets the round timeout in seconds */
void CTffRules :: SetTimeout(inputdata_t& inputdata)
{
	m_fTimeOut = gpGlobals->curtime + inputdata.value.Int();
	SetContextThink(&CTffRules::TimeoutThink, m_fTimeOut, "timeout");
}
/* Delays the end of the round */
void CTffRules :: AddTime(inputdata_t& inputdata)
{
	m_fTimeOut = m_fTimeOut + inputdata.value.Int();
	SetContextThink(&CTffRules::TimeoutThink, m_fTimeOut, "timeout");
}
/* Shortems the round */
void CTffRules :: RemoveTime(inputdata_t& inputdata)
{
	m_fTimeOut = m_fTimeOut - inputdata.value.Int();
	CheckTimeout();

	if (gpGlobals->curtime > m_fTimeOut) return;

	SetContextThink(&CTffRules::TimeoutThink, m_fTimeOut, "timeout");
}
/* Timeout right now */
void CTffRules :: ForceTimeout(inputdata_t& inputdata)
{
	m_fTimeOut = gpGlobals->curtime;
	CheckTimeout();
}

void CTffRules::CheckTimeout()
{
	if (gpGlobals->curtime <= m_fTimeOut) return;

	//tell gamne rules ot was a timeout
	TeamplayGameRules()->SetWinningTeam(TEAM_UNASSIGNED, 2);

	m_OnTimeout.FireOutput(this, this);
	SetPhase(Intermission);
};

void  CTffRules::SetPhase(game_phase NewPhase)
{
	m_phase = NewPhase;
	if (NewPhase == Setup)
	{
		float setupEnds = gpGlobals->curtime + m_iSetupTime;

		SetContextThink(&CTffRules::SetupEndThink, setupEnds, "setup");
	}
	if (NewPhase == Playing)
	{
		m_fTimeOut = gpGlobals->curtime + m_iTimeout;

		SetContextThink(&CTffRules::TimeoutThink, m_fTimeOut, "timeout");
	}
}

game_phase  CTffRules::GetPhase()
{
	return m_phase;
};

void CTffRules::SetupEndThink()
{
	m_OnSetupEnded.FireOutput(this, this);
	SetPhase(Playing);
};

void CTffRules::TimeoutThink()
{
	CheckTimeout();
}